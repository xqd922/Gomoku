import { createState, tryPlaceStone, undo, redo } from './gomoku/engine'
import type { GameState } from './gomoku/types'
import { renderAll, pixelToGrid } from './gomoku/render'
import { NetClient, type NetMessage } from '@/net/ws'

const canvas = document.getElementById('board') as HTMLCanvasElement
const ctx = canvas.getContext('2d')!
const turnDot = document.getElementById('turnDot') as HTMLSpanElement
const turnText = document.getElementById('turnText') as HTMLSpanElement
const statusEl = document.getElementById('status') as HTMLDivElement
const logEl = document.getElementById('log') as HTMLDivElement

const newBtn = document.getElementById('newBtn') as HTMLButtonElement
const undoBtn = document.getElementById('undoBtn') as HTMLButtonElement
const redoBtn = document.getElementById('redoBtn') as HTMLButtonElement
const connectBtn = document.getElementById('connectBtn') as HTMLButtonElement
const disconnectBtn = document.getElementById('disconnectBtn') as HTMLButtonElement
const netStatus = document.getElementById('netStatus') as HTMLDivElement
const roomInput = document.getElementById('roomInput') as HTMLInputElement
const nameInput = document.getElementById('nameInput') as HTMLInputElement
const urlInput = document.getElementById('urlInput') as HTMLInputElement

let state: GameState = createState(15)
let online: NetClient | null = null
let mePlayer: 1 | 2 = 1
let isOnline = false

function updateUI() {
  renderAll(ctx, state)
  const p = state.turn
  turnDot.className = 'dot ' + (p === 1 ? 'black' : 'white')
  turnText.textContent = p === 1 ? 'é»‘å­' : 'ç™½å­'
  if (state.winner) {
    statusEl.textContent = (state.winner === 1 ? 'é»‘å­' : 'ç™½å­') + ' èŽ·èƒœ'
  } else {
    statusEl.textContent = 'è¿›è¡Œä¸?
  }
  netStatus.textContent = isOnline ? `åœ¨çº¿ - çŽ©å®¶${mePlayer}` : 'ç¦»çº¿'
}

let rafPending = false
function requestUpdate() {
  if (rafPending) return
  rafPending = true
  requestAnimationFrame(() => {
    rafPending = false
    updateUI()
  })
}

function log(msg: string) {
  const d = document.createElement('div')
  d.textContent = msg
  logEl.appendChild(d)
  logEl.scrollTop = logEl.scrollHeight
}

canvas.addEventListener('click', (e) => {
  if (state.winner) return
  if (isOnline && state.turn !== mePlayer) return
  const rect = canvas.getBoundingClientRect()
  const scaleX = canvas.width / rect.width
  const scaleY = canvas.height / rect.height
  const x = (e.clientX - rect.left) * scaleX
  const y = (e.clientY - rect.top) * scaleY
  const { r, c } = pixelToGrid(canvas, state.n, 32, x, y)
  const res = tryPlaceStone(state, r, c)
  if (!res.ok) {
    if (res.error === 'out_of_bounds') showToast('è¶Šç•Œï¼šè¯·ç‚¹å‡»æœ‰æ•ˆäº¤ç‚¹')
    else if (res.error === 'occupied') showToast('è¯¥ä½ç½®å·²æœ‰æ£‹å­?)
    else if (res.error === 'game_over') showToast('å½“å‰å¯¹å±€å·²ç»“æ?)
    return
  }
  const m = res.value
  log(`${m.p === 1 ? 'é»? : 'ç™?} è½å­: (${m.r + 1}, ${m.c + 1})`)
  if (isOnline && online) online.send({ type: 'move', r: m.r, c: m.c, p: m.p })
  if (state.winner) {
    const msg = `${state.winner === 1 ? 'é»‘å­' : 'ç™½å­'} èŽ·èƒœï¼`
    log(msg)
    showToast(msg)
  }
  requestUpdate()
})

newBtn.addEventListener('click', () => {
  state = createState(15)
  log('â€?æ–°å±€ â€?)
  if (isOnline && online) online.send({ type: 'reset' })
  requestUpdate()
})
// æ‚”æ£‹/é‡åšï¼šç¦»çº¿ç›´æŽ¥æ‰§è¡Œï¼Œåœ¨çº¿å‘å‡ºè¯·æ±‚
undoBtn.addEventListener('click', () => {
  if (!isOnline) {
    if (undo(state)) { log('æ‚”æ£‹'); requestUpdate() }
  } else if (online) {
    online.send({ type: 'undo_request' } as unknown as NetMessage)
    showToast('å·²å‘é€æ‚”æ£‹è¯·æ±?)
  }
})
redoBtn.addEventListener('click', () => {
  if (!isOnline) {
    if (redo(state)) { log('é‡åš'); requestUpdate() }
  } else if (online) {
    online.send({ type: 'redo_request' } as unknown as NetMessage)
    showToast('å·²å‘é€é‡åšè¯·æ±?)
  }
})

function fitCanvasToDPR() {
  const ratio = Math.max(1, Math.floor(window.devicePixelRatio || 1))
  const rect = canvas.getBoundingClientRect()
  const cssW = Math.max(320, Math.floor(rect.width))
  const cssH = Math.max(320, Math.floor(rect.height))
  canvas.width = Math.round(cssW * ratio)
  canvas.height = Math.round(cssH * ratio)
  requestUpdate()
}

fitCanvasToDPR()
requestUpdate()
window.addEventListener('resize', fitCanvasToDPR)

window.addEventListener('keydown', (e) => {
  const k = e.key.toLowerCase()
  if (e.ctrlKey && k === 'n') {
    e.preventDefault()
    state = createState(15)
    log('â€?æ–°å±€ â€?)
    if (isOnline && online) online.send({ type: 'reset' })
    requestUpdate()
    return
  }
  if (k === 'z') {
    if (!isOnline) {
      if (undo(state)) { log('æ‚”æ£‹'); requestUpdate() }
    } else if (online) {
      online.send({ type: 'undo_request' } as unknown as NetMessage)
      showToast('å·²å‘é€æ‚”æ£‹è¯·æ±?)
    }
  } else if (k === 'y') {
    if (!isOnline) {
      if (redo(state)) { log('é‡åš'); requestUpdate() }
    } else if (online) {
      online.send({ type: 'redo_request' } as unknown as NetMessage)
      showToast('å·²å‘é€é‡åšè¯·æ±?)
    }
  } else if (k === 'r') {
    state = createState(15)
    log('â€?æ–°å±€ â€?)
    if (isOnline && online) online.send({ type: 'reset' })
    requestUpdate()
  }
})

declare global {
  interface Window { api: unknown }
}

// ç®€æ˜?Toast æç¤ºï¼ˆéžé˜»å¡žï¼?let toastTimer: number | null = null
function showToast(text: string) {
  const el = document.getElementById('toast') as HTMLDivElement | null
  if (!el) return
  el.textContent = text
  el.classList.add('show')
  if (toastTimer) {
    window.clearTimeout(toastTimer)
    toastTimer = null
  }
  toastTimer = window.setTimeout(() => {
    el.classList.remove('show')
  }, 2200)
}

// åœ¨çº¿è”æœº
connectBtn.addEventListener('click', () => {
  if (isOnline) return
  const url = urlInput.value || 'ws://localhost:8787'
  const room = roomInput.value || 'test'
  const name = nameInput.value || ''
  const client = new NetClient()
  client.connect({ url, room, name, autoReconnect: true })
  client.addEventListener('message', (ev: MessageEvent<NetMessage>) => {
    const msg = ev.data
    if (msg.type === 'welcome') {
      mePlayer = msg.player
      isOnline = true
      connectBtn.disabled = true
      disconnectBtn.disabled = false
      undoBtn.disabled = true
      redoBtn.disabled = true
      requestUpdate()
    } else if (msg.type === 'ready') {
      if (mePlayer === 1) {
        client.send({ type: 'state', snapshot: state })
      } else {
        client.send({ type: 'request_state' })
      }
    } else if (msg.type === 'state') {
      try {
        const snap = msg.snapshot as GameState
        state = snap
        requestUpdate()
      } catch {}
    } else if (msg.type === 'request_state') {
      if (mePlayer === 1) client.send({ type: 'state', snapshot: state })
    } else if (msg.type === 'move') {
      if (state.turn === msg.p) {
        tryPlaceStone(state, msg.r, msg.c)
        requestUpdate()
      }
    } else if ((msg as any).type === 'undo_request') {
      const ok = window.confirm('å¯¹æ–¹è¯·æ±‚æ‚”æ£‹ï¼Œæ˜¯å¦åŒæ„ï¼Ÿ')
      if (ok) {
        if (undo(state)) requestUpdate()
        client.send({ type: 'undo_reply', accepted: true } as unknown as NetMessage)
      } else {
        client.send({ type: 'undo_reply', accepted: false } as unknown as NetMessage)
      }
    } else if ((msg as any).type === 'undo_reply') {
      const { accepted } = msg as any
      if (accepted) {
        if (undo(state)) requestUpdate()
      } else {
        showToast('å¯¹æ–¹æ‹’ç»äº†æ‚”æ£?)
      }
    } else if ((msg as any).type === 'redo_request') {
      const ok = window.confirm('å¯¹æ–¹è¯·æ±‚é‡åšï¼Œæ˜¯å¦åŒæ„ï¼Ÿ')
      if (ok) {
        if (redo(state)) requestUpdate()
        client.send({ type: 'redo_reply', accepted: true } as unknown as NetMessage)
      } else {
        client.send({ type: 'redo_reply', accepted: false } as unknown as NetMessage)
      }
    } else if ((msg as any).type === 'redo_reply') {
      const { accepted } = msg as any
      if (accepted) {
        if (redo(state)) requestUpdate()
      } else {
        showToast('å¯¹æ–¹æ‹’ç»äº†é‡å?)
      }
    } else if (msg.type === 'reset') {
      state = createState(15)
      requestUpdate()
    } else if (msg.type === 'peer_leave') {
      showToast('å¯¹æ–¹å·²ç¦»å¼€æˆ¿é—´')
    } else if (msg.type === 'error') {
      showToast('è¿žæŽ¥é”™è¯¯: ' + msg.message)
    }
  })
  client.addEventListener('close', () => {
    isOnline = false
    connectBtn.disabled = false
    disconnectBtn.disabled = true
    undoBtn.disabled = false
    redoBtn.disabled = false
    requestUpdate()
  })
  client.addEventListener('reconnecting', (e: any) => {
    netStatus.textContent = `é‡è¿žä¸?.. ${e.detail?.delay ?? ''}ms`
  })
  client.addEventListener('reconnected', () => {
    netStatus.textContent = 'å·²å°è¯•é‡è¿?
  })
  online = client
})

disconnectBtn.addEventListener('click', () => {
  if (online) online.disconnect()
})
